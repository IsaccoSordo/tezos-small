# Tezos Small

> An Angular 21 application for exploring Tezos blockchain blocks and transactions through the TZKT API.

This is a single-page application featuring block browsing, transaction details, zoneless change detection, standalone components, and HTTP interceptors for error handling and loading states. The project uses TypeScript strict mode, RxJS for reactive patterns, and PrimeNG Aura theme for UI.

**Stack**: Angular 21, TypeScript 5.9, PrimeNG 21, RxJS 7.8, NgRx Signals, @ngneat/cashew, TZKT API
**Node Requirements**: v20.19+ or v22.12+
**Last Updated**: 2025-12-14
**Dependencies**: All dependencies use exact versions (no wildcards like ^ or ~)

## Core Documentation

- [README.md](README.md): Complete project overview, features, quick start guide, testing instructions, and architecture documentation
- [package.json](package.json): Dependencies, scripts, and project metadata
- [tsconfig.json](tsconfig.json): TypeScript strict mode configuration
- [angular.json](angular.json): Angular CLI and build configuration
- [vitest.config.ts](vitest.config.ts): Vitest test runner configuration

## Application Configuration

- [src/main.ts](src/main.ts): Application bootstrap with zoneless change detection
- [src/app/app.config.ts](src/app/app.config.ts): Global providers, HTTP interceptors registration, PrimeNG theme configuration (Aura preset)
- [src/app/app.routes.ts](src/app/app.routes.ts): Application routing configuration with lazy loading

## TypeScript Interfaces

- [src/app/common.ts](src/app/common.ts): All shared TypeScript interfaces

## Services & State Management

- [src/app/services/tzkt.service.ts](src/app/services/tzkt.service.ts): TZKT API integration service for blockchain data (blocks, transactions, counts)
- [src/app/store/tzkt.store.ts](src/app/store/tzkt.store.ts): Global state management using **NgRx SignalStore** with `withState` and `withMethods` for scalable, maintainable state management
- [src/app/store/auth.store.ts](src/app/store/auth.store.ts): Authentication state management using **NgRx SignalStore**

## Routing & Authentication

- [src/app/guards/auth.guard.ts](src/app/guards/auth.guard.ts): Route guards for authentication (authGuard, guestGuard)
- [src/app/resolvers/tzkt.resolvers.ts](src/app/resolvers/tzkt.resolvers.ts): Functional resolvers for preloading route data (blocks, count, transactions)
- [src/app/services/auth.service.ts](src/app/services/auth.service.ts): Authentication service for login/logout operations

## HTTP Interceptors

- [src/app/interceptors/loading.interceptor.ts](src/app/interceptors/loading.interceptor.ts): Functional interceptor for automatic loading state management using counter-based approach
- [src/app/interceptors/error.interceptor.ts](src/app/interceptors/error.interceptor.ts): Centralized HTTP error handling - displays PrimeNG toast notifications, logs errors, and returns EMPTY observable to prevent error propagation
- **HTTP Caching**: Uses [@ngneat/cashew](https://github.com/ngneat/cashew) for response caching via `withCache()` context in service methods

## Error Handling

- [src/app/core/global-error.handler.ts](src/app/core/global-error.handler.ts): Custom Angular ErrorHandler for unhandled exceptions

## Smart/Container Components

- [src/app/app.component.ts](src/app/app.component.ts): Root application component
- [src/app/navbar/navbar.component.ts](src/app/navbar/navbar.component.ts): Navigation header with authentication logic (login/logout)
- [src/app/blocks-overview/blocks-overview.component.ts](src/app/blocks-overview/blocks-overview.component.ts): Main blocks listing page with pagination and polling
- [src/app/details/details.component.ts](src/app/details/details.component.ts): Transaction details page for individual blocks
- [src/app/login/login.component.ts](src/app/login/login.component.ts): Login page with OAuth provider selection

## Presentational Components

- [src/app/ui/table/table.component.ts](src/app/ui/table/table.component.ts): Generic data table with pagination, sorting, and customizable columns using PrimeNG Table
- [src/app/ui/spinner/spinner.component.ts](src/app/ui/spinner/spinner.component.ts): Loading indicator using PrimeNG ProgressSpinner

## Documentation Style Guidelines

**IMPORTANT: When writing or updating documentation (README, comments, commit messages, etc.), follow these principles:**

**Language Standards**
- Use neutral, objective language - avoid subjective adjectives
- Avoid marketing terms: "enterprise-grade", "premium", "cutting-edge", "sleek", "modern", "beautiful", "powerful", "robust"
- Avoid promotional phrases: "deep-dive", "smart", "comprehensive", "industry-standard"
- Do NOT use emojis in documentation unless explicitly requested
- State facts, not opinions - describe what the code does, not how good it is
- Use technical terminology appropriately without exaggeration

**Writing Style**
- Be concise and direct
- Focus on functionality, not aesthetics
- Use active voice when describing what the code does
- Avoid superlatives and excessive enthusiasm
- Keep descriptions factual and verifiable

**Examples of Neutral vs. Grandiose Language**
- ❌ "A sleek, modern Angular application" → ✅ "An Angular application"
- ❌ "Enterprise-grade UI components" → ✅ "Angular UI component library"
- ❌ "Beautiful, premium icons" → ✅ "Icon library"
- ❌ "Smart loading states" → ✅ "Loading states"
- ❌ "Comprehensive testing best practices" → ✅ "Unit tests for components and services"
- ❌ "Industry-standard state management" → ✅ "NgRx SignalStore for state management"

**What IS Acceptable**
- Technical specifications and version numbers
- Factual descriptions of features
- Neutral descriptions of architecture patterns
- Clear installation and usage instructions
- Objective comparisons when necessary

## Angular 21 Best Practices

**TypeScript Standards**
- Use strict type checking (enabled in tsconfig.json)
- Avoid `any` types; prefer explicit interfaces
- Leverage type inference where appropriate
- Define interfaces for all API responses and data models

**Angular Conventions**
- Use standalone components (no NgModules)
- Use **NgRx SignalStore** for state management (installed: @ngrx/signals)
- Organize state with `withState()` for initial state and `withMethods()` for state updates
- Use `patchState()` for immutable state updates in SignalStore methods
- State properties are automatically exposed as signals by SignalStore
- Use functional HTTP interceptors with `withInterceptors()`
- Enable zoneless change detection for better performance
- Use `input()` and `output()` functions for component APIs
- Apply OnPush change detection strategy

**Component Patterns**
- Keep components small and focused (single responsibility)
- Use smart/container components for data management
- Use presentational components for UI rendering
- Implement proper lifecycle hooks
- Unsubscribe from observables to prevent memory leaks

**Template Organization**
- Use inline `template` for simple/presentational components with no complex logic
- Use `templateUrl` with separate HTML file for smart/container components with logic
- Smart components: have services, subscriptions, Subject patterns, or business logic
- Presentational components: receive inputs, emit outputs, no service injection

**Template Guidance**
- Use native control flow (`@if`, `@for`, `@switch`) instead of structural directives
- Avoid complex logic in templates
- Use async pipe for observables
- Leverage signals with `()` syntax for reactive updates

**Service Design**
- Use `providedIn: 'root'` for singleton services
- Follow single responsibility principle
- Return observables for async operations
- Handle errors gracefully with proper error messages
- For state management: use NgRx SignalStore with `withState()` and `withMethods()` patterns
- Use `patchState()` for all state updates to ensure immutability

**Subscription Patterns (CRITICAL)**
- NEVER subscribe inside method functions - use Subject pattern instead
- NEVER subscribe in constructors - always use ngOnInit for subscriptions
- Always use `takeUntilDestroyed(this.destroyRef)` to automatically unsubscribe
- For user actions: use Subject to trigger, switchMap to handle async, subscribe in ngOnInit
- Services return observables; components manage subscriptions in ngOnInit only

**Subject Pattern for User Actions**
```typescript
private actionTrigger$ = new Subject<string>();

ngOnInit(): void {
  this.actionTrigger$
    .pipe(
      switchMap((param) => this.service.doSomething(param)),
      takeUntilDestroyed(this.destroyRef)
    )
    .subscribe(() => {
      // handle result
    });
}

onUserAction(param: string): void {
  this.actionTrigger$.next(param);  // just trigger, no subscribe
}
```

**Zoneless Architecture**
- Project uses zoneless change detection - NEVER use NgZone
- Signals automatically trigger change detection
- No need for manual change detection calls

**Centralized Loading State**
- Loading state is handled by the loading interceptor via Store.loadingCounter
- NEVER create component-level isLoading properties
- Use Store.incrementLoadingCounter() / decrementLoadingCounter() for non-HTTP async operations
- Global SpinnerComponent shows when loadingCounter > 0

**Centralized Error Handling**
- Errors are handled by the error interceptor - shows toast notifications
- NEVER handle errors in components or use catchError in component subscriptions
- Error interceptor returns EMPTY, so component subscriptions complete safely

**RxJS Patterns**
- Use `tap` for side effects without transforming values
- Use `map` for value transformations
- Use `catchError` for error handling
- Use `finalize` for cleanup operations
- Use `forkJoin` for combining parallel requests

**Route Resolvers (CRITICAL)**
- Use functional resolvers (class-based resolvers are deprecated since Angular 16)
- Resolvers preload data before component renders - no loading states needed in resolved components
- Use `inject()` function to access services within resolver functions
- Resolvers block navigation until data is loaded - use sparingly for critical data only
- Secondary/non-critical data should still be loaded in ngOnInit
- Configure `withComponentInputBinding()` in router for type-safe resolved data access
- Use `runGuardsAndResolvers: 'paramsOrQueryParamsChange'` for routes with pagination

**Functional Resolver Pattern**
```typescript
import { inject } from '@angular/core';
import { ResolveFn, ActivatedRouteSnapshot } from '@angular/router';

export const dataResolver: ResolveFn<DataType[]> = (
  route: ActivatedRouteSnapshot
) => {
  const service = inject(DataService);
  const id = route.paramMap.get('id');
  return service.getData(id);
};
```

**Route Configuration with Resolver**
```typescript
{
  path: 'details/:id',
  loadComponent: () => import('./details.component').then(m => m.DetailsComponent),
  resolve: {
    data: dataResolver,
  },
}
```

**Accessibility**
- Ensure WCAG AA compliance
- Use semantic HTML elements
- Provide ARIA labels where needed
- PrimeNG components include built-in accessibility support

## API Integration

**TZKT API** (https://api.tzkt.io/v1)
- Base URL: `https://api.tzkt.io/v1`
- `/blocks/count`: Total block count
- `/blocks?limit=X&offset=Y`: Paginated blocks
- `/operations/transactions/count?level=X`: Transaction count per block
- `/operations/transactions?level=X`: Block transactions

**Integration Notes**
- All HTTP calls go through interceptors (loading + error + cache)
- Caching configured per-request using `withCache({ ttl: ms })` from @ngneat/cashew
- No manual loading/error state management needed in services
- Responses are mapped to TypeScript interfaces (Block, Transaction)
- Counter-based loading ensures proper handling of concurrent requests

## Testing

**Test Files**
- [src/app/app.component.spec.ts](src/app/app.component.spec.ts): Root component tests
- [src/app/services/tzkt.service.spec.ts](src/app/services/tzkt.service.spec.ts): API service tests with HttpClientTestingModule
- [src/app/blocks-overview/blocks-overview.component.spec.ts](src/app/blocks-overview/blocks-overview.component.spec.ts): Blocks page tests
- [src/app/details/details.component.spec.ts](src/app/details/details.component.spec.ts): Details page tests
- [src/app/ui/table/table.component.spec.ts](src/app/ui/table/table.component.spec.ts): Table component tests
- [src/app/ui/spinner/spinner.component.spec.ts](src/app/ui/spinner/spinner.component.spec.ts): Spinner component tests
- [src/app/navbar/navbar.component.spec.ts](src/app/navbar/navbar.component.spec.ts): Navbar tests

**Testing Commands**
- `npm test`: Run tests in watch mode
- `npm run test:ci`: Run tests once (for CI/automated testing)
- `npm test -- --coverage`: Generate coverage reports

**Testing Best Practices**
- Use Vitest for test framework (describe, it, expect, vi)
- Uses jsdom for DOM emulation (no browser needed)
- Mock HTTP calls with HttpClientTestingModule and HttpTestingController
- Test component inputs, outputs, and user interactions
- Verify error handling and edge cases
- Aim for high code coverage

**Test Organization Patterns**
- Create helper functions to reduce duplication (e.g., `initializeComponent()`, `flushCountRequest()`)
- Use nested describe blocks to group related tests by feature/scenario
- Each test should have a single, focused responsibility
- Use clear test names with "should..." statements
- Add JSDoc headers to test suites documenting best practices applied

**Async Testing Patterns**
- Use `vi.useFakeTimers()` with `vi.advanceTimersByTime()` for timer-based operations
- Always call `fixture.destroy()` in afterEach to cleanup subscriptions
- Use `httpMock.verify()` in afterEach to ensure no pending HTTP requests
- Call `vi.useRealTimers()` in afterEach to restore real timers
- Use `vi.spyOn()` for spying on methods

**Example Test Pattern**
```typescript
/**
 * ComponentName Test Suite
 *
 * Testing Best Practices Applied:
 * - Helper functions reduce code duplication
 * - Each test has single responsibility
 * - vi.useFakeTimers() for async operations
 * - fixture.destroy() ensures cleanup
 */
describe('ComponentName', () => {
  let component, fixture, httpMock, store;

  // Helper functions
  const initializeComponent = () => {
    fixture.detectChanges();
    vi.advanceTimersByTime(0); // Trigger timers
  };

  const flushMockRequest = () => {
    const req = httpMock.expectOne(url);
    req.flush(data);
  };

  beforeEach(async () => {
    vi.useFakeTimers();
    // Setup test fixtures
  });

  afterEach(() => {
    fixture.destroy();
    httpMock.verify();
    vi.useRealTimers();
  });

  it('should do something specific', () => {
    initializeComponent();
    flushMockRequest();

    expect(component.data()).toBeTruthy();
  });
});
```

**Reference Implementation**
- See [src/app/blocks-overview/blocks-overview.component.spec.ts](src/app/blocks-overview/blocks-overview.component.spec.ts) for complete example
- All major test files have JSDoc headers with patterns used

## Architecture Patterns

**State Management**
- Centralized signal-based state in `StoreService`
- Reactive updates using Angular Signals

**Data Flow**
1. Component calls service method
2. Service makes HTTP request to TZKT API
3. Loading interceptor increments counter
4. Response/error handled by interceptors
5. Service updates store with new data
6. Components react to signal changes

**Error Handling Flow**
1. HTTP errors caught by error interceptor
2. User-friendly toast notifications displayed
3. Error logged to console for debugging
4. Global error handler catches unhandled exceptions

## PrimeNG Components Used

- `p-table`: Data tables with pagination, sorting, filtering
- `p-progressSpinner`: Loading indicators
- `p-toast`: Toast notifications for errors and messages
- `p-button`: Styled buttons

## Development Commands

- `npm install`: Install dependencies (no --legacy-peer-deps or --force flags needed)
- `npm start`: Start development server on http://localhost:4200
- `npm run build`: Production build to dist/tezos-small
- `npm run watch`: Build in watch mode
- `npm test`: Run tests
- `npm run lint`: Run ESLint

**Dependency Management**
- All package versions are pinned to exact versions (no ^ or ~ wildcards)
- Use `npm install` without --legacy-peer-deps or --force flags
- No manual dependency resolution needed

## Optional

**Additional Resources**
- [Angular Documentation](https://angular.io/docs): Official Angular framework docs
- [Angular AI Development Guide](https://angular.dev/ai/develop-with-ai): Guidelines for using LLMs with Angular projects
- [PrimeNG Documentation](https://primeng.org): UI component library documentation
- [TZKT API Documentation](https://tzkt.io/api/): Tezos blockchain API reference
- [RxJS Documentation](https://rxjs.dev/): Reactive programming library docs
- [TypeScript Handbook](https://www.typescriptlang.org/docs/): TypeScript language reference

**Project Repository**
- GitHub: https://github.com/IsaccoSordo/tezos-small

**License**
- GNU GENERAL PUBLIC LICENSE (see LICENCE file)

**Browser Support**
- Modern browsers (Chrome, Firefox, Safari, Edge)
- Tests use jsdom for DOM emulation

**Code Style**
- OnPush change detection for performance
- Standalone components architecture
- TypeScript strict mode enabled
- SCSS styling with modular components
- BEM naming conventions

## Project Structure Rules

**Directory Organization**
- All guards go in `src/app/guards/` folder (e.g., auth.guard.ts, admin.guard.ts)
- All resolvers go in `src/app/resolvers/` folder (e.g., tzkt.resolvers.ts)
- All interfaces go in `src/app/common.ts` file (consolidated in one file)
- All stores go in `src/app/store/` folder (e.g., tzkt.store.ts, auth.store.ts)
- State files follow naming pattern: `<domain>.store.ts` (not `store.service.ts`)
- Login components go in `src/app/login/` folder (moved from auth subfolder)
- Services go in `src/app/services/` folder (e.g., tzkt.service.ts, auth.service.ts)
- HTTP interceptors go in `src/app/interceptors/` folder
- UI components go in `src/app/ui/` folder with subdirectories per component
- Feature components (pages) go directly in `src/app/` with their own directories

**Import Path Conventions**
- Always use relative imports from sibling folders: `../store/`, `../services/`, `../guards/`, `../resolvers/`
- Use absolute imports for deeply nested components: `src/app/store/` from UI components
- Guard imports in routes: `'./guards/auth.guard'`
- Resolver imports in routes: `'./resolvers/tzkt.resolvers'`
- Store imports: `'../store/tzkt.store'`, `'../store/auth.store'`
- Interface imports: `'../common'` (all interfaces in single file)
