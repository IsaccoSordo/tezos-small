# Tezos Small

> An Angular 21 application for exploring Tezos blockchain blocks and transactions through the TZKT API.

This is a single-page application featuring block browsing, transaction details, Firebase authentication with OAuth providers, zoneless change detection, standalone components, and HTTP interceptors for error handling and loading states. The project uses TypeScript strict mode, RxJS for reactive patterns, and PrimeNG Aura theme for UI.

**Stack**: Angular 21, TypeScript 5.9, PrimeNG 21, RxJS 7.8, NgRx Signals, @angular/fire, @ngneat/cashew, Firebase Auth, TZKT API
**Node Requirements**: v20.19+ or v22.12+
**Last Updated**: 2025-12-23
**Dependencies**: All dependencies use exact versions (no wildcards like ^ or ~)
**Live Demo**: https://isaccosordo.github.io/tezos-small/

## Core Documentation

- [README.md](README.md): Complete project overview, features, quick start guide, testing instructions, and architecture documentation
- [package.json](package.json): Dependencies, scripts, and project metadata
- [tsconfig.json](tsconfig.json): TypeScript strict mode configuration
- [angular.json](angular.json): Angular CLI and build configuration
- [vitest.config.ts](vitest.config.ts): Vitest test runner configuration

## Application Configuration

- [src/main.ts](src/main.ts): Application bootstrap with zoneless change detection
- [src/app/app.config.ts](src/app/app.config.ts): Global providers including Firebase (`provideFirebaseApp`, `provideAuth`), HTTP interceptors, and PrimeNG theme (Aura preset)
- [src/app/app.routes.ts](src/app/app.routes.ts): Application routing configuration with lazy loading and auth guards

## Environment Configuration

Environment files are **generated at build time** from environment variables - they are NOT committed to the repository.

- [scripts/set-env.ts](scripts/set-env.ts): Script to generate environment files from environment variables
- [.env.example](.env.example): Template for local environment variables
- `src/environments/environment.ts`: Generated development config (gitignored)
- `src/environments/environment.prod.ts`: Generated production config (gitignored)

**Environment Variables (GitHub Secrets)**
- `FIREBASE_API_KEY`: Firebase API key
- `FIREBASE_PROJECT_ID`: Firebase project ID
- `FIREBASE_APP_ID`: Firebase app ID
- `FIREBASE_SENDER_ID`: Firebase messaging sender ID
- `FIREBASE_MEASUREMENT_ID`: Firebase Analytics measurement ID

**Local Development Setup**
1. Copy `.env.example` to `.env`
2. Fill in your Firebase credentials
3. Run `npm start` (automatically generates environment files)

**CI/CD Integration**
- GitHub Actions workflow injects secrets at build time
- Secrets are configured in repository settings: Settings > Secrets and variables > Actions > Environments > production
- Build and deploy only run on push to main (not on pull requests)
- Deployed to GitHub Pages at https://isaccosordo.github.io/tezos-small/

## TypeScript Models

Interfaces are organized in a `models/` directory using domain-based organization with a barrel file for clean imports.

- [src/app/models/index.ts](src/app/models/index.ts): Barrel file - re-exports all interfaces for simplified imports
- [src/app/models/tzkt.model.ts](src/app/models/tzkt.model.ts): TZKT domain models (Block, Transaction, Account, TZKTState)
- [src/app/models/auth.model.ts](src/app/models/auth.model.ts): Authentication models (User)
- [src/app/models/ui.model.ts](src/app/models/ui.model.ts): UI component models (Column, TableData)

## Services & State Management

- [src/app/services/tzkt.service.ts](src/app/services/tzkt.service.ts): TZKT API integration service for blockchain data (blocks, transactions, counts) - thin HTTP layer only
- [src/app/services/auth.service.ts](src/app/services/auth.service.ts): Firebase Authentication service using `@angular/fire` and `toSignal()` pattern - NO subscriptions, NO constructor needed
- [src/app/store/tzkt.store.ts](src/app/store/tzkt.store.ts): Orchestrator store using composable `signalStoreFeature` functions
- [src/app/store/features/](src/app/store/features/): Composable store features:
  - `state-mutations.feature.ts`: withStateMutations - basic setters and resetState
  - `blocks-data.feature.ts`: withBlocksData - loadBlocks, loadBlocksCount, pollBlocksCount rxMethods
  - `transactions-data.feature.ts`: withTransactionsData - loadTransactions rxMethod
  - `router-sync.feature.ts`: withRouterSync - handleRouteChange + Router event subscription in onInit
  - `url-utils.ts`: URL parsing utilities (getRouteType, getPaginationParams, getDetailsLevel)

## Authentication (Firebase via @angular/fire)

The application uses `@angular/fire` for Firebase integration with signal-based state:

- [src/app/services/auth.service.ts](src/app/services/auth.service.ts): Core auth service using `toSignal()` pattern
  - `user()` signal: Current Firebase user (automatically updates on auth state changes)
  - `token()` signal: ID token (automatically refreshes)
  - `isAuthenticated()` computed signal: Boolean auth status
  - `pendingLink()` signal: For account linking flow
  - `login(provider)`: Google/GitHub OAuth via popup
  - `completeAccountLinking()`: Links accounts with same email
- [src/app/config/auth.config.ts](src/app/config/auth.config.ts): Protected API patterns for auth interceptor
- [src/app/guards/auth.guard.ts](src/app/guards/auth.guard.ts): Route guards (authGuard, guestGuard)

**Key Pattern - toSignal for Auth State:**
```typescript
@Injectable({ providedIn: 'root' })
export class AuthService {
  private auth = inject(Auth);

  // Firebase observables converted to signals - no subscriptions needed
  private firebaseUser = toSignal(user(this.auth));
  readonly token = toSignal(idToken(this.auth));

  // Computed signals for derived state
  readonly user = computed(() => this.mapFirebaseUser(this.firebaseUser()));
  readonly isAuthenticated = computed(() => !!this.firebaseUser());
}
```

## Routing & Guards

- [src/app/guards/auth.guard.ts](src/app/guards/auth.guard.ts): Functional route guards using `inject(AuthService)`
- Routes do NOT use resolvers - the store handles all data loading via Router events

## HTTP Interceptors

- [src/app/interceptors/auth.interceptor.ts](src/app/interceptors/auth.interceptor.ts): Attaches Bearer token to protected API requests using `AuthService.token()` signal
- [src/app/interceptors/loading.interceptor.ts](src/app/interceptors/loading.interceptor.ts): Functional interceptor for automatic loading state management using counter-based approach
- [src/app/interceptors/error.interceptor.ts](src/app/interceptors/error.interceptor.ts): Centralized HTTP error handling - displays PrimeNG toast notifications, logs errors, and returns EMPTY observable to prevent error propagation
- **HTTP Caching**: Uses [@ngneat/cashew](https://github.com/ngneat/cashew) for response caching via `withCache()` context in service methods

## Error Handling

- [src/app/core/global-error.handler.ts](src/app/core/global-error.handler.ts): Custom Angular ErrorHandler for unhandled exceptions

## Components

**Root & Navigation**
- [src/app/app.component.ts](src/app/app.component.ts): Root application component
- [src/app/navbar/navbar.component.ts](src/app/navbar/navbar.component.ts): Navigation header with authentication status display
- [src/app/login/login.component.ts](src/app/login/login.component.ts): Login page with OAuth provider selection (Google, GitHub) and account linking UI

**Presentational Page Components** (read from store, no data fetching)
- [src/app/blocks-overview/blocks-overview.component.ts](src/app/blocks-overview/blocks-overview.component.ts): Displays blocks from store, handles URL-driven pagination
- [src/app/details/details.component.ts](src/app/details/details.component.ts): Displays transactions from store

**Reusable UI Components**
- [src/app/ui/table/table.component.ts](src/app/ui/table/table.component.ts): Generic data table with pagination, sorting, and customizable columns using PrimeNG Table
- [src/app/ui/spinner/spinner.component.ts](src/app/ui/spinner/spinner.component.ts): Loading indicator using PrimeNG ProgressSpinner

## Documentation Style Guidelines

**IMPORTANT: When writing or updating documentation (README, comments, commit messages, etc.), follow these principles:**

**Language Standards**
- Use neutral, objective language - avoid subjective adjectives
- Avoid marketing terms: "enterprise-grade", "premium", "cutting-edge", "sleek", "modern", "beautiful", "powerful", "robust"
- Avoid promotional phrases: "deep-dive", "smart", "comprehensive", "industry-standard"
- Do NOT use emojis in documentation unless explicitly requested
- State facts, not opinions - describe what the code does, not how good it is
- Use technical terminology appropriately without exaggeration

**Writing Style**
- Be concise and direct
- Focus on functionality, not aesthetics
- Use active voice when describing what the code does
- Avoid superlatives and excessive enthusiasm
- Keep descriptions factual and verifiable

**Examples of Neutral vs. Grandiose Language**
- "A sleek, modern Angular application" -> "An Angular application"
- "Enterprise-grade UI components" -> "Angular UI component library"
- "Beautiful, premium icons" -> "Icon library"
- "Smart loading states" -> "Loading states"
- "Comprehensive testing best practices" -> "Unit tests for components and services"
- "Industry-standard state management" -> "NgRx SignalStore for state management"

**What IS Acceptable**
- Technical specifications and version numbers
- Factual descriptions of features
- Neutral descriptions of architecture patterns
- Clear installation and usage instructions
- Objective comparisons when necessary

## Angular 21 Best Practices

**TypeScript Standards**
- Use strict type checking (enabled in tsconfig.json)
- Avoid `any` types; prefer explicit interfaces
- Leverage type inference where appropriate
- Define interfaces for all API responses and data models

**Interface Organization (SCALABLE)**
- Use domain-based organization: group interfaces by business domain, not by type
- File naming: use `<domain>.model.ts` suffix (e.g., tzkt.model.ts, auth.model.ts)
- Keep related interfaces together: Account, Block, Transaction all in tzkt.model.ts
- State interfaces stay with their domain: TZKTState in tzkt.model.ts
- Use barrel files (index.ts) for clean imports: `import { Block, User } from '../models'`
- Re-export using `export type { ... }` for type-only exports
- Component-specific types can be co-located with components for encapsulation
- NEVER create separate folders by type (e.g., /interfaces/, /types/, /enums/)

**Barrel File Pattern**
```typescript
// src/app/models/index.ts
export type { Account, Block, Transaction, TZKTState } from './tzkt.model';
export type { User } from './auth.model';
export type { Column, TableData } from './ui.model';
```

**Angular Conventions**
- Use standalone components (no NgModules)
- Use **NgRx SignalStore** for TZKT state management (installed: @ngrx/signals)
- Use **@angular/fire** with `toSignal()` pattern for Firebase auth state
- Organize state with `withState()` for initial state, `withMethods()` for state updates, and `withHooks()` for initialization
- Use `rxMethod` from `@ngrx/signals/rxjs-interop` for reactive data loading - accepts Observable, Signal, or static value
- Use `signalStoreFeature` for composable, reusable store slices (plugin architecture)
- Use `patchState()` for immutable state updates in SignalStore methods
- State properties are automatically exposed as signals by SignalStore
- Use functional HTTP interceptors with `withInterceptors()`
- Enable zoneless change detection for better performance
- Use `input()` and `output()` functions for component APIs
- Apply OnPush change detection strategy

**Component Patterns**
- Keep components small and focused (single responsibility)
- Use smart/container components for data management
- Use presentational components for UI rendering
- Implement proper lifecycle hooks
- Unsubscribe from observables to prevent memory leaks

**Template Organization**
- Use inline `template` for simple/presentational components with no complex logic
- Use `templateUrl` with separate HTML file for smart/container components with logic
- Smart components: have services, subscriptions, Subject patterns, or business logic
- Presentational components: receive inputs, emit outputs, no service injection

**Template Guidance**
- Use native control flow (`@if`, `@for`, `@switch`) instead of structural directives
- Avoid complex logic in templates
- Use async pipe for observables
- Leverage signals with `()` syntax for reactive updates

**Service Design**
- Use `providedIn: 'root'` for singleton services
- Follow single responsibility principle
- Return observables for async operations
- Handle errors gracefully with proper error messages
- For TZKT state: use NgRx SignalStore with `withState()`, `withMethods()`, and `withHooks()` patterns
- Use `rxMethod` for reactive data loading - NO manual `.subscribe()` calls in store
- For Firebase auth: use `toSignal()` pattern with `@angular/fire` observables
- Use `patchState()` for all state updates to ensure immutability

**Subscription Patterns (CRITICAL)**
- NEVER subscribe inside method functions - use Subject pattern instead
- NEVER subscribe in constructors - always use ngOnInit for subscriptions
- Always use `takeUntilDestroyed(this.destroyRef)` to automatically unsubscribe
- For user actions: use Subject to trigger, switchMap to handle async, subscribe in ngOnInit
- Services return observables; components manage subscriptions in ngOnInit only
- For Firebase auth state: use `toSignal()` - NO subscriptions needed

**Subject Pattern for User Actions**
```typescript
private actionTrigger$ = new Subject<string>();

ngOnInit(): void {
  this.actionTrigger$
    .pipe(
      switchMap((param) => this.service.doSomething(param)),
      takeUntilDestroyed(this.destroyRef)
    )
    .subscribe(() => {
      // handle result
    });
}

onUserAction(param: string): void {
  this.actionTrigger$.next(param);  // just trigger, no subscribe
}
```

**Zoneless Architecture**
- Project uses zoneless change detection - NEVER use NgZone
- Signals automatically trigger change detection
- No need for manual change detection calls

**Centralized Loading State**
- Loading state is handled by the loading interceptor via Store.loadingCounter
- NEVER create component-level isLoading properties
- Use Store.incrementLoadingCounter() / decrementLoadingCounter() for non-HTTP async operations
- Global SpinnerComponent shows when loadingCounter > 0

**Centralized Error Handling**
- Errors are handled by the error interceptor - shows toast notifications
- NEVER handle errors in components or use catchError in component subscriptions
- Error interceptor returns EMPTY, so component subscriptions complete safely

**RxJS Patterns**
- Use `tap` for side effects without transforming values
- Use `map` for value transformations
- Use `catchError` for error handling
- Use `finalize` for cleanup operations
- Use `forkJoin` for combining parallel requests

**Route-Driven State Management (CRITICAL)**
- Store subscribes to Router events via `withHooks()` - components do NOT fetch data
- Use `rxMethod` to react to URL changes - no manual `.subscribe()` calls
- Components are purely presentational: read from store signals, navigate on user actions
- URL is the single source of truth for pagination (queryParams) and detail views (route params)
- URL pagination is 1-indexed for UX (`?page=1` is first page), converted to 0-indexed for API/PrimeNG

**signalStoreFeature Pattern (Plugin Architecture)**

Use `signalStoreFeature` to split large stores into composable, testable slices:

```typescript
// blocks-data.feature.ts - Reusable feature slice
export function withBlocksData() {
  return signalStoreFeature(
    { state: type<TZKTState>() }, // State requirements
    withMethods((store, service = inject(TzktService)) => ({
      loadBlocks: rxMethod<{ pageSize: number; page: number }>(
        pipe(
          switchMap(({ pageSize, page }) =>
            service.getBlocks(pageSize, page).pipe(
              tapResponse({
                next: (blocks) => patchState(store, { blocks }),
                error: (error) => patchState(store, (state) => ({
                  errors: [...state.errors, error],
                })),
              })
            )
          )
        )
      ),
    }))
  );
}

// router-sync.feature.ts - Router integration feature
export function withRouterSync() {
  return signalStoreFeature(
    { state: type<TZKTState>(), methods: type<DataLoadingMethods>() },
    withHooks((store) => {
      const router = inject(Router);
      return {
        onInit() {
          const navigationEnd$ = router.events.pipe(
            filter((e): e is NavigationEnd => e instanceof NavigationEnd),
            map((e) => e.urlAfterRedirects)
          );
          const initialUrl$ = router.navigated
            ? of(router.url)
            : navigationEnd$.pipe(take(1));
          const currentUrl$ = merge(initialUrl$, navigationEnd$).pipe(distinctUntilChanged());

          store.loadBlocks(currentUrl$.pipe(/* filter & map */));
        },
      };
    })
  );
}

// tzkt.store.ts - Clean orchestrator
export const Store = signalStore(
  { providedIn: 'root' },
  withState<TZKTState>({ blocks: [], count: 0, transactions: [], errors: [], loadingCounter: 0 }),
  withStateMutations(),    // Basic setters and resetState
  withBlocksData(),        // Block loading rxMethods
  withTransactionsData(),  // Transaction loading rxMethods
  withRouterSync()         // Must be last - needs access to all methods
);
```

**signalStoreFeature Benefits:**
- Readability: Main store goes from 200+ lines to 20 lines
- Testability: Test each feature slice in isolation
- Reusability: Share features across stores (e.g., `withPolling()`, `withPagination()`)
- Collaboration: Fewer git merge conflicts with separate files
- Naming convention: Use `withX` prefix for feature functions

**Accessibility**
- Ensure WCAG AA compliance
- Use semantic HTML elements
- Provide ARIA labels where needed
- PrimeNG components include built-in accessibility support

## API Integration

**TZKT API** (https://api.tzkt.io/v1)
- Base URL: `https://api.tzkt.io/v1`
- `/blocks/count`: Total block count
- `/blocks?limit=X&offset=Y`: Paginated blocks
- `/operations/transactions/count?level=X`: Transaction count per block
- `/operations/transactions?level=X`: Block transactions

**Integration Notes**
- All HTTP calls go through interceptors (auth + loading + error + cache)
- Auth interceptor adds Bearer token for protected API patterns
- Caching configured per-request using `withCache({ ttl: ms })` from @ngneat/cashew
- No manual loading/error state management needed in services
- Responses are mapped to TypeScript interfaces (Block, Transaction)
- Counter-based loading ensures proper handling of concurrent requests

## Testing

**Test Files**
- [src/app/app.component.spec.ts](src/app/app.component.spec.ts): Root component tests
- [src/app/services/tzkt.service.spec.ts](src/app/services/tzkt.service.spec.ts): API service tests with HttpClientTestingModule
- [src/app/blocks-overview/blocks-overview.component.spec.ts](src/app/blocks-overview/blocks-overview.component.spec.ts): Blocks page tests
- [src/app/details/details.component.spec.ts](src/app/details/details.component.spec.ts): Details page tests
- [src/app/ui/table/table.component.spec.ts](src/app/ui/table/table.component.spec.ts): Table component tests
- [src/app/ui/spinner/spinner.component.spec.ts](src/app/ui/spinner/spinner.component.spec.ts): Spinner component tests
- [src/app/navbar/navbar.component.spec.ts](src/app/navbar/navbar.component.spec.ts): Navbar tests

**Testing Commands**
- `npm test`: Run tests in watch mode
- `npm run test:ci`: Run tests once (for CI/automated testing)
- `npm test -- --coverage`: Generate coverage reports

**Testing Best Practices**
- Use Vitest for test framework (describe, it, expect, vi)
- Uses jsdom for DOM emulation (no browser needed)
- Mock HTTP calls with HttpClientTestingModule and HttpTestingController
- Mock AuthService with signals for components that inject it
- Test component inputs, outputs, and user interactions
- Verify error handling and edge cases
- Aim for high code coverage

**Mocking AuthService in Tests**
```typescript
const mockAuthService = {
  user: signal(null),
  token: signal(null),
  isAuthenticated: signal(false),
  pendingLink: signal(null),
};

// In TestBed providers:
{ provide: AuthService, useValue: mockAuthService }
```

**Mocking Store in Tests** (for presentational components)
```typescript
const mockStore = {
  blocks: signal<Block[]>([]),
  count: signal(0),
  transactions: signal<Transaction[]>([]),
  errors: signal<Error[]>([]),
  loadingCounter: signal(0),
  loadBlocks: vi.fn(),
  pollBlocksCount: vi.fn(),
  loadTransactions: vi.fn(),
  resetState: vi.fn(),
};

// In TestBed providers:
{ provide: Store, useValue: mockStore }

// In tests, set signal values directly:
mockStore.blocks.set(mockBlocks);
mockStore.count.set(1000);
fixture.detectChanges();
```

**Test Organization Patterns**
- Create helper functions to reduce duplication (e.g., `initializeComponent()`, `flushCountRequest()`)
- Use nested describe blocks to group related tests by feature/scenario
- Each test should have a single, focused responsibility
- Use clear test names with "should..." statements
- Add JSDoc headers to test suites documenting best practices applied

**Async Testing Patterns**
- Use `vi.useFakeTimers()` with `vi.advanceTimersByTime()` for timer-based operations
- Always call `fixture.destroy()` in afterEach to cleanup subscriptions
- Use `httpMock.verify()` in afterEach to ensure no pending HTTP requests
- Call `vi.useRealTimers()` in afterEach to restore real timers
- Use `vi.spyOn()` for spying on methods

**Example Test Pattern**
```typescript
/**
 * ComponentName Test Suite
 *
 * Testing Best Practices Applied:
 * - Helper functions reduce code duplication
 * - Each test has single responsibility
 * - vi.useFakeTimers() for async operations
 * - fixture.destroy() ensures cleanup
 */
describe('ComponentName', () => {
  let component, fixture, httpMock, store;

  // Helper functions
  const initializeComponent = () => {
    fixture.detectChanges();
    vi.advanceTimersByTime(0); // Trigger timers
  };

  const flushMockRequest = () => {
    const req = httpMock.expectOne(url);
    req.flush(data);
  };

  beforeEach(async () => {
    vi.useFakeTimers();
    // Setup test fixtures
  });

  afterEach(() => {
    fixture.destroy();
    httpMock.verify();
    vi.useRealTimers();
  });

  it('should do something specific', () => {
    initializeComponent();
    flushMockRequest();

    expect(component.data()).toBeTruthy();
  });
});
```

**Reference Implementation**
- See [src/app/blocks-overview/blocks-overview.component.spec.ts](src/app/blocks-overview/blocks-overview.component.spec.ts) for complete example
- All major test files have JSDoc headers with patterns used

## Architecture Patterns

**State Management**
- TZKT state: Centralized signal-based state in NgRx SignalStore (`tzkt.store.ts`) with `rxMethod` for reactive loading
- Auth state: Signal-based state in AuthService using `toSignal()` from `@angular/fire` observables
- Reactive updates using Angular Signals
- Store is 100% subscription-free via `rxMethod` - no manual `.subscribe()` calls

**Data Flow (Route-Driven)**
1. User navigates (URL change triggers Router event)
2. Store's `withHooks.onInit()` receives NavigationEnd event
3. URL is parsed and piped into appropriate `rxMethod` (loadBlocks, loadTransactions, etc.)
4. Service makes HTTP request to TZKT API
5. Auth interceptor adds token if needed
6. Loading interceptor increments counter
7. Response/error handled by interceptors and `tapResponse`
8. Store updates state via `patchState()`
9. Components react to signal changes (purely presentational)

**Authentication Flow**
1. User clicks login button
2. `AuthService.login(provider)` opens OAuth popup
3. Firebase handles OAuth and returns user
4. `toSignal(user(this.auth))` automatically updates `firebaseUser` signal
5. `computed()` signals (`user`, `isAuthenticated`) update automatically
6. Components react to signal changes

**Account Linking Flow**
1. User tries to login with provider B but email exists with provider A
2. Error caught, credential stored in `pendingLink` signal
3. UI shows message asking user to sign in with existing provider
4. User clicks, triggering user-initiated popup (avoids popup blocker)
5. After login, `linkWithCredential` links the accounts

**Error Handling Flow**
1. HTTP errors caught by error interceptor
2. User-friendly toast notifications displayed
3. Error logged to console for debugging
4. Global error handler catches unhandled exceptions

## PrimeNG Components Used

- `p-table`: Data tables with pagination, sorting, filtering
- `p-progressSpinner`: Loading indicators
- `p-toast`: Toast notifications for errors and messages
- `p-button`: Styled buttons
- `p-message`: Info/warning messages (for account linking UI)

## Development Commands

- `npm install`: Install dependencies (no --legacy-peer-deps or --force flags needed)
- `npm start`: Start development server on http://localhost:4200
- `npm run build`: Development build to dist/tezos-small
- `npm run build:prod`: Generate env files and build for production
- `npm run set-env`: Generate environment files from environment variables
- `npm run watch`: Build in watch mode
- `npm test`: Run tests
- `npm run lint`: Run ESLint

**Dependency Management**
- All package versions are pinned to exact versions (no ^ or ~ wildcards)
- Use `npm install` without --legacy-peer-deps or --force flags
- No manual dependency resolution needed

## CI/CD (GitHub Actions)

- [.github/workflows/ci.yml](.github/workflows/ci.yml): CI/CD workflow
- **On Pull Request**: Runs lint, format, and test jobs
- **On Push to Main**: Runs lint, format, test, build, and deploy to GitHub Pages
- Environment secrets stored in `production` environment in GitHub repo settings
- Uses `actions/deploy-pages@v4` for GitHub Pages deployment

## Optional

**Additional Resources**
- [Angular Documentation](https://angular.io/docs): Official Angular framework docs
- [Angular AI Development Guide](https://angular.dev/ai/develop-with-ai): Guidelines for using LLMs with Angular projects
- [AngularFire Documentation](https://github.com/angular/angularfire): Firebase + Angular integration
- [Firebase Authentication](https://firebase.google.com/docs/auth): Firebase Auth documentation
- [PrimeNG Documentation](https://primeng.org): UI component library documentation
- [TZKT API Documentation](https://tzkt.io/api/): Tezos blockchain API reference
- [RxJS Documentation](https://rxjs.dev/): Reactive programming library docs
- [TypeScript Handbook](https://www.typescriptlang.org/docs/): TypeScript language reference

**Project Repository**
- GitHub: https://github.com/IsaccoSordo/tezos-small

**License**
- GNU GENERAL PUBLIC LICENSE (see LICENCE file)

**Browser Support**
- Modern browsers (Chrome, Firefox, Safari, Edge)
- Tests use jsdom for DOM emulation

**Code Style**
- OnPush change detection for performance
- Standalone components architecture
- TypeScript strict mode enabled
- SCSS styling with modular components
- BEM naming conventions

## Project Structure Rules

**Directory Organization**
- All guards go in `src/app/guards/` folder (e.g., auth.guard.ts)
- All interfaces go in `src/app/models/` folder with domain-based organization
- All stores go in `src/app/store/` folder (e.g., tzkt.store.ts)
- Store features go in `src/app/store/features/` folder (e.g., blocks-data.feature.ts)
- Feature files follow naming pattern: `<name>.feature.ts` with `withX` function export
- State files follow naming pattern: `<domain>.store.ts`
- Login components go in `src/app/login/` folder
- Services go in `src/app/services/` folder (e.g., tzkt.service.ts, auth.service.ts)
- Config files go in `src/app/config/` folder (e.g., auth.config.ts, cache.config.ts)
- HTTP interceptors go in `src/app/interceptors/` folder
- UI components go in `src/app/ui/` folder with subdirectories per component
- Feature components (pages) go directly in `src/app/` with their own directories

**Models Directory Organization**
- Use domain-based file organization (e.g., tzkt.model.ts, auth.model.ts, ui.model.ts)
- Each domain file groups related interfaces together
- Use barrel file (index.ts) to re-export all interfaces for simplified imports
- Use `.model.ts` suffix for interface files
- Keep state interfaces with their domain (e.g., TZKTState in tzkt.model.ts)
- Component-specific types can remain co-located with components (e.g., PageChangeEvent in table.component.ts)

**Import Path Conventions**
- Always use relative imports from sibling folders: `../store/`, `../services/`, `../guards/`, `../models/`
- Use absolute imports for deeply nested components: `src/app/store/` from UI components
- Guard imports in routes: `'./guards/auth.guard'`
- Store imports: `'../store/tzkt.store'`
- Store feature imports: `'./features'` (imports from barrel file)
- Model imports: `'../models'` (imports from barrel file, not individual domain files)
- Config imports: `'../config/auth.config'`, `'../config/cache.config'`
