# Tezos Small

> An Angular 21 application for exploring Tezos blockchain blocks and transactions through the TZKT API.

This is a single-page application featuring block browsing, transaction details, zoneless change detection, standalone components, and HTTP interceptors for error handling and loading states. The project uses TypeScript strict mode, RxJS for reactive patterns, and PrimeNG Aura theme for UI.

**Stack**: Angular 21, TypeScript 5.9, PrimeNG 21, RxJS 7.8, NgRx Signals, @ngneat/cashew, TZKT API
**Node Requirements**: v20.19+ or v22.12+
**Last Updated**: 2025-12-14
**Dependencies**: All dependencies use exact versions (no wildcards like ^ or ~)

## Core Documentation

- [README.md](README.md): Complete project overview, features, quick start guide, testing instructions, and architecture documentation
- [package.json](package.json): Dependencies, scripts, and project metadata
- [tsconfig.json](tsconfig.json): TypeScript strict mode configuration
- [angular.json](angular.json): Angular CLI and build configuration
- [karma.conf.js](karma.conf.js): Multi-browser test runner configuration

## Application Configuration

- [src/main.ts](src/main.ts): Application bootstrap with zoneless change detection
- [src/app/app.config.ts](src/app/app.config.ts): Global providers, HTTP interceptors registration, PrimeNG theme configuration (Aura preset)
- [src/app/app.routes.ts](src/app/app.routes.ts): Application routing configuration with lazy loading

## TypeScript Interfaces

- [src/app/common.ts](src/app/common.ts): Shared TypeScript interfaces (Block, Transaction, Account, Column, TableConfig)

## Services & State Management

- [src/app/services/tzkt.service.ts](src/app/services/tzkt.service.ts): TZKT API integration service for blockchain data (blocks, transactions, counts)
- [src/app/store/store.service.ts](src/app/store/store.service.ts): Global state management using **NgRx SignalStore** with `withState` and `withMethods` for scalable, maintainable state management

## HTTP Interceptors

- [src/app/interceptors/loading.interceptor.ts](src/app/interceptors/loading.interceptor.ts): Functional interceptor for automatic loading state management using counter-based approach
- [src/app/interceptors/error.interceptor.ts](src/app/interceptors/error.interceptor.ts): Centralized HTTP error handling - displays PrimeNG toast notifications, logs errors, and returns EMPTY observable to prevent error propagation
- **HTTP Caching**: Uses [@ngneat/cashew](https://github.com/ngneat/cashew) for response caching via `withCache()` context in service methods

## Error Handling

- [src/app/core/global-error.handler.ts](src/app/core/global-error.handler.ts): Custom Angular ErrorHandler for unhandled exceptions

## Components

- [src/app/app.component.ts](src/app/app.component.ts): Root application component
- [src/app/navbar/navbar.component.ts](src/app/navbar/navbar.component.ts): Navigation header with branding
- [src/app/blocks-overview/blocks-overview.component.ts](src/app/blocks-overview/blocks-overview.component.ts): Main blocks listing page with pagination and real-time counts
- [src/app/details/details.component.ts](src/app/details/details.component.ts): Transaction details page for individual blocks

## Reusable UI Components

- [src/app/ui/table/table.component.ts](src/app/ui/table/table.component.ts): Generic data table with pagination, sorting, and customizable columns using PrimeNG Table
- [src/app/ui/spinner/spinner.component.ts](src/app/ui/spinner/spinner.component.ts): Loading indicator using PrimeNG ProgressSpinner

## Documentation Style Guidelines

**IMPORTANT: When writing or updating documentation (README, comments, commit messages, etc.), follow these principles:**

**Language Standards**
- Use neutral, objective language - avoid subjective adjectives
- Avoid marketing terms: "enterprise-grade", "premium", "cutting-edge", "sleek", "modern", "beautiful", "powerful", "robust"
- Avoid promotional phrases: "deep-dive", "smart", "comprehensive", "industry-standard"
- Do NOT use emojis in documentation unless explicitly requested
- State facts, not opinions - describe what the code does, not how good it is
- Use technical terminology appropriately without exaggeration

**Writing Style**
- Be concise and direct
- Focus on functionality, not aesthetics
- Use active voice when describing what the code does
- Avoid superlatives and excessive enthusiasm
- Keep descriptions factual and verifiable

**Examples of Neutral vs. Grandiose Language**
- ❌ "A sleek, modern Angular application" → ✅ "An Angular application"
- ❌ "Enterprise-grade UI components" → ✅ "Angular UI component library"
- ❌ "Beautiful, premium icons" → ✅ "Icon library"
- ❌ "Smart loading states" → ✅ "Loading states"
- ❌ "Comprehensive testing best practices" → ✅ "Unit tests for components and services"
- ❌ "Industry-standard state management" → ✅ "NgRx SignalStore for state management"

**What IS Acceptable**
- Technical specifications and version numbers
- Factual descriptions of features
- Neutral descriptions of architecture patterns
- Clear installation and usage instructions
- Objective comparisons when necessary

## Angular 21 Best Practices

**TypeScript Standards**
- Use strict type checking (enabled in tsconfig.json)
- Avoid `any` types; prefer explicit interfaces
- Leverage type inference where appropriate
- Define interfaces for all API responses and data models

**Angular Conventions**
- Use standalone components (no NgModules)
- Use **NgRx SignalStore** for state management (installed: @ngrx/signals)
- Organize state with `withState()` for initial state and `withMethods()` for state updates
- Use `patchState()` for immutable state updates in SignalStore methods
- State properties are automatically exposed as signals by SignalStore
- Use functional HTTP interceptors with `withInterceptors()`
- Enable zoneless change detection for better performance
- Use `input()` and `output()` functions for component APIs
- Apply OnPush change detection strategy

**Component Patterns**
- Keep components small and focused (single responsibility)
- Use smart/container components for data management
- Use presentational/dumb components for UI rendering
- Implement proper lifecycle hooks
- Unsubscribe from observables to prevent memory leaks

**Template Guidance**
- Use native control flow (`@if`, `@for`, `@switch`) instead of structural directives
- Avoid complex logic in templates
- Use async pipe for observables
- Leverage signals with `()` syntax for reactive updates

**Service Design**
- Use `providedIn: 'root'` for singleton services
- Follow single responsibility principle
- Return observables for async operations
- Handle errors gracefully with proper error messages
- For state management: use NgRx SignalStore with `withState()` and `withMethods()` patterns
- Use `patchState()` for all state updates to ensure immutability

**RxJS Patterns**
- Use `tap` for side effects without transforming values
- Use `map` for value transformations
- Use `catchError` for error handling
- Use `finalize` for cleanup operations
- Use `forkJoin` for combining parallel requests

**Accessibility**
- Ensure WCAG AA compliance
- Use semantic HTML elements
- Provide ARIA labels where needed
- PrimeNG components include built-in accessibility support

## API Integration

**TZKT API** (https://api.tzkt.io/v1)
- Base URL: `https://api.tzkt.io/v1`
- `/blocks/count`: Total block count
- `/blocks?limit=X&offset=Y`: Paginated blocks
- `/operations/transactions/count?level=X`: Transaction count per block
- `/operations/transactions?level=X`: Block transactions

**Integration Notes**
- All HTTP calls go through interceptors (loading + error + cache)
- Caching configured per-request using `withCache({ ttl: ms })` from @ngneat/cashew
- No manual loading/error state management needed in services
- Responses are mapped to TypeScript interfaces (Block, Transaction)
- Counter-based loading ensures proper handling of concurrent requests

## Testing

**Test Files**
- [src/app/app.component.spec.ts](src/app/app.component.spec.ts): Root component tests
- [src/app/services/tzkt.service.spec.ts](src/app/services/tzkt.service.spec.ts): API service tests with HttpClientTestingModule
- [src/app/blocks-overview/blocks-overview.component.spec.ts](src/app/blocks-overview/blocks-overview.component.spec.ts): Blocks page tests
- [src/app/details/details.component.spec.ts](src/app/details/details.component.spec.ts): Details page tests
- [src/app/ui/table/table.component.spec.ts](src/app/ui/table/table.component.spec.ts): Table component tests
- [src/app/ui/spinner/spinner.component.spec.ts](src/app/ui/spinner/spinner.component.spec.ts): Spinner component tests
- [src/app/navbar/navbar.component.spec.ts](src/app/navbar/navbar.component.spec.ts): Navbar tests

**Testing Commands**
- `npm test`: Run tests in watch mode with browser auto-detection
- `npm test -- --watch=false`: Run tests once without watch mode (use this for CI/automated testing)
- `npm test:headless`: Run tests in ChromeHeadless without watch
- `npm test -- --code-coverage`: Generate coverage reports

**Testing Best Practices**
- Use Jasmine for test framework (describe, it, expect)
- Use Karma for test runner with multi-browser support
- Mock HTTP calls with HttpClientTestingModule and HttpTestingController
- Test component inputs, outputs, and user interactions
- Verify error handling and edge cases
- Aim for high code coverage

**Test Organization Patterns**
- Create helper functions to reduce duplication (e.g., `initializeComponent()`, `flushCountRequest()`)
- Use nested describe blocks to group related tests by feature/scenario
- Each test should have a single, focused responsibility
- Use clear test names with "should..." statements
- Add JSDoc headers to test suites documenting best practices applied

**Async Testing Patterns**
- Use `fakeAsync` with `tick()` for timer-based operations (e.g., `timer(0, 60000)`)
- Always call `fixture.destroy()` in fakeAsync tests to cleanup subscriptions
- Use `httpMock.verify()` in afterEach to ensure no pending HTTP requests
- For observable-based async: use `done` callback or `fakeAsync` with `tick()`
- Handle `takeUntilDestroyed()` by destroying fixture before test ends

**Example Test Pattern**
```typescript
/**
 * ComponentName Test Suite
 *
 * Testing Best Practices Applied:
 * - Helper functions reduce code duplication
 * - Each test has single responsibility
 * - fakeAsync with tick() for async operations
 * - fixture.destroy() ensures cleanup
 */
describe('ComponentName', () => {
  let component, fixture, httpMock, store;

  // Helper functions
  const initializeComponent = () => {
    fixture.detectChanges();
    tick(); // Trigger timers
  };

  const flushMockRequest = () => {
    const req = httpMock.expectOne(url);
    req.flush(data);
  };

  beforeEach(async () => {
    // Setup test fixtures
  });

  afterEach(() => {
    httpMock.verify();
  });

  it('should do something specific', fakeAsync(() => {
    initializeComponent();
    flushMockRequest();

    expect(component.data()).toBeTruthy();

    fixture.destroy(); // Critical for cleanup
  }));
});
```

**Reference Implementation**
- See [src/app/blocks-overview/blocks-overview.component.spec.ts](src/app/blocks-overview/blocks-overview.component.spec.ts) for complete example
- All major test files have JSDoc headers with patterns used

## Architecture Patterns

**State Management**
- Centralized signal-based state in `StoreService`
- Reactive updates using Angular Signals
- No external state management library needed

**Data Flow**
1. Component calls service method
2. Service makes HTTP request to TZKT API
3. Loading interceptor increments counter
4. Response/error handled by interceptors
5. Service updates store with new data
6. Components react to signal changes

**Error Handling Flow**
1. HTTP errors caught by error interceptor
2. User-friendly toast notifications displayed
3. Error logged to console for debugging
4. Global error handler catches unhandled exceptions

## PrimeNG Components Used

- `p-table`: Data tables with pagination, sorting, filtering
- `p-progressSpinner`: Loading indicators
- `p-toast`: Toast notifications for errors and messages
- `p-button`: Styled buttons

## Development Commands

- `npm install`: Install dependencies (no --legacy-peer-deps or --force flags needed)
- `npm start`: Start development server on http://localhost:4200
- `npm run build`: Production build to dist/tezos-small
- `npm run watch`: Build in watch mode
- `npm test`: Run tests
- `npm run lint`: Run ESLint

**Dependency Management**
- All package versions are pinned to exact versions (no ^ or ~ wildcards)
- Use `npm install` without --legacy-peer-deps or --force flags
- No manual dependency resolution needed

## Optional

**Additional Resources**
- [Angular Documentation](https://angular.io/docs): Official Angular framework docs
- [Angular AI Development Guide](https://angular.dev/ai/develop-with-ai): Guidelines for using LLMs with Angular projects
- [PrimeNG Documentation](https://primeng.org): UI component library documentation
- [TZKT API Documentation](https://tzkt.io/api/): Tezos blockchain API reference
- [RxJS Documentation](https://rxjs.dev/): Reactive programming library docs
- [TypeScript Handbook](https://www.typescriptlang.org/docs/): TypeScript language reference

**Project Repository**
- GitHub: https://github.com/IsaccoSordo/tezos-small

**License**
- GNU GENERAL PUBLIC LICENSE (see LICENCE file)

**Browser Support**
- Modern browsers (Chrome, Firefox, Safari, Edge)
- Test runner auto-detects installed browsers

**Code Style**
- OnPush change detection for performance
- Standalone components architecture
- TypeScript strict mode enabled
- SCSS styling with modular components
- BEM naming conventions
